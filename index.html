<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>Visualizza file GLB con Animazioni e Distinta Base</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100%; height: 100vh; }
        
        #animationContainer { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            z-index: 100; 
            width: 250px;
        }
        
        #bomContainer { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            z-index: 100; 
            width: 250px;
        }
        
        .panel {
            background: rgba(255, 255, 255, 0.9);
            margin-bottom: 5px;
            border-radius: 3px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .panel-header {
            padding: 10px;
            cursor: pointer;
            background: #f5f5f5;
            border-radius: 3px;
            user-select: none;
        }
        
        .panel-header:hover {
            background: #e5e5e5;
        }
        
        .panel-content {
            padding: 10px;
            max-height: 40vh;
            overflow-y: auto;
            display: none;
        }
        
        .panel-content.active {
            display: block;
        }
        
        .animation-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .animation-list li {
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 3px;
            background: #fff;
            margin-bottom: 2px;
        }
        
        .animation-list li:hover {
            background: #f0f0f0;
        }
        
        .animation-list li.active {
            background: #cce5ff;
            font-weight: bold;
        }
        
        .bom-item {
            display: flex;
            align-items: center;
            margin: 2px 0;
        }
        
        .bom-button { 
            flex-grow: 1;
            padding: 5px 10px; 
            cursor: pointer; 
            border: none;
            background: #fff;
            border-radius: 3px;
            text-align: left;
        }
        
        .bom-button:hover { 
            background: #f0f0f0; 
        }
        
        .bom-button.selected {
            background: #ffcccc;
            font-weight: bold;
        }
        
        .visibility-toggle {
            width: 20px;
            height: 20px;
            margin-left: 5px;
            cursor: pointer;
            background: #ddd;
            border: none;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .visibility-toggle:hover {
            background: #ccc;
        }
        
        .visibility-toggle.hidden {
            background: #ff9999;
        }
        
        #controlsBar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
        }
        
        #controlsBar button {
            width: 40px;
            height: 40px;
            font-size: 20px;
            border: none;
            background: #f5f5f5;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        #controlsBar button:hover {
            background: #e5e5e5;
        }
    </style>
</head>
<body>
    <div id="animationContainer">
        <div class="panel" id="animationPanel">
            <div class="panel-header">Animazioni</div>
            <div class="panel-content" id="animationControls">
                <ul class="animation-list" id="animationList"></ul>
            </div>
        </div>
    </div>
    <div id="bomContainer">
        <div class="panel" id="bomPanel">
            <div class="panel-header">Distinta Base</div>
            <div class="panel-content" id="bomControls">
                <!-- Pulsanti distinta base aggiunti dinamicamente -->
            </div>
        </div>
    </div>
    <div id="controlsBar">
        <button id="playAllButton" title="Esegui tutte">▶</button>
        <button id="pauseButton" title="Pausa">⏸</button>
        <button id="stopButton" title="Ferma">⏹</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.134/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Inizializza la scena
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xdddddd);

        // Inizializza la telecamera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        // Inizializza il renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Aggiungi i controlli orbitali
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = true;
        controls.zoomSpeed = 1.0;
        controls.minDistance = 0.1;
        controls.maxDistance = 1;

        // Aggiungi luci
        const light = new THREE.HemisphereLight(0xffffff, 0x444444);
        light.position.set(0, 20, 0);
        scene.add(light);
        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(0, 20, 10);
        scene.add(directionalLight);

        // Variabili globali
        let mixer;
        let actions = [];
        let modelParts = [];
        let model;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();
        const animationList = document.getElementById('animationList');
        const bomControls = document.getElementById('bomControls');
        let buttonMap = new Map();
        let visibilityMap = new Map();
        let isPlayingAll = false;
        let activeAnimationItem = null;

        // Funzione per impostare lo stato finale delle animazioni precedenti
        function setPreviousAnimations(index) {
            for (let i = 0; i < index; i++) {
                const action = actions[i];
                action.reset();
                action.time = action.getClip().duration;
                mixer.update(0);
            }
        }

        // Funzione per eseguire una singola animazione con sequenzialità
        function playAnimation(index, listItem) {
            if (mixer && actions[index]) {
                actions.forEach(action => action.stop());
                setPreviousAnimations(index);

                const action = actions[index];
                action.setLoop(THREE.LoopOnce);
                action.clampWhenFinished = true;
                action.reset();
                action.play();

                if (activeAnimationItem) activeAnimationItem.classList.remove('active');
                listItem.classList.add('active');
                activeAnimationItem = listItem;
            }
        }

        function stopAllAnimations() {
            if (mixer) {
                actions.forEach(action => action.stop());
                isPlayingAll = false;
                if (activeAnimationItem) activeAnimationItem.classList.remove('active');
                activeAnimationItem = null;
            }
        }

        function pauseAnimations() {
            if (mixer) {
                actions.forEach(action => {
                    if (action.isRunning()) action.paused = true;
                });
                isPlayingAll = false;
            }
        }

        function playAllAnimationsSequentially() {
            if (mixer && actions.length > 0 && !isPlayingAll) {
                isPlayingAll = true;
                let currentIndex = 0;
                const listItems = animationList.getElementsByTagName('li');

                function playNext() {
                    if (currentIndex >= actions.length || !isPlayingAll) {
                        isPlayingAll = false;
                        if (activeAnimationItem) activeAnimationItem.classList.remove('active');
                        activeAnimationItem = null;
                        return;
                    }

                    const action = actions[currentIndex];
                    action.reset();
                    action.play();

                    if (activeAnimationItem) activeAnimationItem.classList.remove('active');
                    listItems[currentIndex].classList.add('active');
                    activeAnimationItem = listItems[currentIndex];

                    mixer.addEventListener('finished', function onFinished(e) {
                        if (e.action === action) {
                            mixer.removeEventListener('finished', onFinished);
                            currentIndex++;
                            playNext();
                        }
                    });
                }

                playNext();
            }
        }

        let originalMaterials = new Map();
        function highlightPart(part, button) {
            if (!model) return;

            model.traverse((child) => {
                if (child.isMesh && originalMaterials.has(child)) {
                    child.material = originalMaterials.get(child);
                }
            });
            buttonMap.forEach((btn) => btn.classList.remove('selected'));

            part.traverse((child) => {
                if (child.isMesh) {
                    if (!originalMaterials.has(child)) {
                        originalMaterials.set(child, child.material.clone());
                    }
                    child.material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                }
            });

            if (button) {
                button.classList.add('selected');
            }
        }

        function toggleVisibility(part, toggleButton) {
            const isHidden = visibilityMap.get(part) || false;
            const newState = !isHidden;
            visibilityMap.set(part, newState);

            part.traverse((child) => {
                if (child.isMesh) {
                    child.visible = !newState;
                }
            });

            toggleButton.classList.toggle('hidden', newState);
            toggleButton.textContent = newState ? '👁️‍🗨️' : '👁️';
        }

        function onMouseClick(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(model.children, true);
            if (intersects.length > 0) {
                const intersectedObject = intersects[0].object;
                let parent = intersectedObject;
                while (parent.parent && parent.parent !== model) {
                    parent = parent.parent;
                }
                if (modelParts.includes(parent)) {
                    const button = buttonMap.get(parent);
                    highlightPart(parent, button);
                }
            }
        }

        // Carica il modello GLB
        const loader = new THREE.GLTFLoader();
        loader.load(
            'https://raw.githubusercontent.com/sandropertini/Models/main/W037089_An_5.glb',
            function (gltf) {
                model = gltf.scene;
                scene.add(model);

                mixer = new THREE.AnimationMixer(model);

                // Filtra e ordina le animazioni con nome "Stepn"
                const stepAnimations = gltf.animations
                    .filter(clip => /^Step\d+$/.test(clip.name)) // Filtra solo "Step" seguito da numero
                    .map(clip => ({
                        clip,
                        number: parseInt(clip.name.match(/\d+$/)[0], 10) // Estrai il numero
                    }))
                    .sort((a, b) => a.number - b.number); // Ordina per numero crescente

                // Popola l'array actions e l'elenco
                stepAnimations.forEach((anim, index) => {
                    const action = mixer.clipAction(anim.clip);
                    action.setLoop(THREE.LoopOnce);
                    action.clampWhenFinished = true;
                    actions.push(action);
                    const listItem = document.createElement('li');
                    listItem.textContent = anim.clip.name;
                    listItem.addEventListener('click', () => playAnimation(index, listItem));
                    animationList.appendChild(listItem);
                });

                if (stepAnimations.length === 0) {
                    console.log("Nessuna animazione 'Stepn' trovata nel modello.");
                }

                model.children.forEach((child, index) => {
                    modelParts.push(child);
                    const bomItem = document.createElement('div');
                    bomItem.className = 'bom-item';
                    const button = document.createElement('button');
                    button.className = 'bom-button';
                    const partName = child.name && child.name !== '' ? child.name : `Parte ${index + 1}`;
                    button.textContent = partName;
                    button.addEventListener('click', () => highlightPart(child, button));
                    bomItem.appendChild(button);
                    const visibilityButton = document.createElement('button');
                    visibilityButton.className = 'visibility-toggle';
                    visibilityButton.textContent = '👁️';
                    visibilityButton.addEventListener('click', () => toggleVisibility(child, visibilityButton));
                    bomItem.appendChild(visibilityButton);
                    bomControls.appendChild(bomItem);
                    buttonMap.set(child, button);
                    visibilityMap.set(child, false);
                    console.log(`Nome child: ${child.name}`);
                });

                if (model.children.length === 0) {
                    console.log("Nessun child trovato nel modello.");
                }

                document.getElementById('playAllButton').addEventListener('click', playAllAnimationsSequentially);
                document.getElementById('pauseButton').addEventListener('click', pauseAnimations);
                document.getElementById('stopButton').addEventListener('click', stopAllAnimations);
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% caricato');
            },
            function (error) {
                console.error('Errore durante il caricamento:', error);
            }
        );

        // Gestione collapsible panels
        document.querySelectorAll('.panel-header').forEach(header => {
            header.addEventListener('click', () => {
                const content = header.nextElementSibling;
                content.classList.toggle('active');
            });
        });

        window.addEventListener('click', onMouseClick, false);

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            if (mixer) mixer.update(delta);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
